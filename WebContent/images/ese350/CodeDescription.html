<html>
<b>void display(char x)</b></br>
The display function is used to display the ten millions, millions, hundred thousands, and ten thousands digits of inputA or inputB.  Display takes in a character x as a parameter so that it can properly display whether to show the inputA or inputB digit depending on the rti phase.  It also checks whether the LEDs are displaying inputA or inputB to check if it needs to light up the LED to represent a negative digit as well as whether to light up the decimal digit to represent a decimal.</br></br>
<b>void displayB(char x)</b></br>
The display function is used to display the thousands, hundreds, tens, and ones digits of inputA or inputB.  Display takes in a character x as a parameter so that it can properly display whether to show the inputA or inputB digit depending on the rti phase.  It also checks whether the LEDs are displaying inputA or inputB to check if it needs to light up the LED to represent a negative digit as well as whether to light up the decimal digit.</br></br>
<b>void enterA()</b></br>
The enterA function checks whether it is the first number being entered and if true to transfer it to the inputB array along with the negative and decimal point variable flags.  If it is not then it checks if abs was pressed and runs the function and runs functionB which switches between which function to run.</br></br>
<b>void functionB()</b></br>
The functionB function switches between the different functions that were desired.  The global variable function recorded whether at this stage the calculator should add, subtract, multiply, divide, tenToX, which needed its own functions to do this.  The function variable would be set in the RTI phase according to the cases in the switch in this function.</br></br>
<b>void add()</b></br>
The add function adds inputA to inputB and stores the result in inputB while telling it to now display inputB instead of inputA.  It first checks whether inputB is a decimal and whether inputA is not a decimal to increment inputA by 2 spaces to line it up properly like how regular addition is performed.  Then, it checks the opposite if inputB is not a decimal but inputA is to increment inputB by 2 and set inputB to be a decimal now since we just basically multiplied it by ten.  Now, the program proceeds to checking if the number being operated on is negative but the currently inputted number is not so that we swap the elements of inputA and inputB and perform the subtraction function instead of the rest of the function while also reseting negative A and B to being positive.  This is because if you think about it adding a negative number and a positive number is the same as taking the positive number and subtracting the absolute value of the negative number.  Then, it checks whether the currently inputted number is negative and the number being operated on is positive.  This is the same philosophy where we don't swap but we do perform a subtract function because it is the same operation as subtracting the absolute value of the currently negative inputted number.  The next possibility that the program checks for is whether both numbers are negative and just sets the currently inputted number to positive and subtracts the two.  Now, we have hit the point where we have two positive numbers which we are adding so we have to manipulate arrays here to perform this function.  We loop through the arrays at the same time focusing on the same element of each array one at a time.  First, we add the two elements and store it in a temporary variable.  If that number is greater than 9 then we set num to temp plus the carry from the previous time this was called (0 if first time), but otherwise we would just do temp plus carry.  If num is 10 we had to set the element to 0 because it would carry the one and set the zero but otherwise would just set the num to the element.  Now that we have figured out what goes into the element, we figured out whether there should be a carry for the next element.  If temp plus carry was greater than 10, then we would set carry to be 1 otherwise to 0.  At the end we set the inputA element to 0 to reset it for next time and increment the while loop by incrementing countY.  We set displayInputA to 1 to display the result B now and set isDot to 0 since we know it is positive.</br></br>
<b>void sub()</b></br>
The subtraction function first checks to make sure that the currently inputted number and the number being operated on are lined up correctly depending on whether they are decimal numbers.  It checks whether the number being operated on is a decimal and the currently inputted number is not and if so increments the currently inputted number so that it lines up with the number being operated on.  If this is not true, then it checks to see if the currently inputted number is a decimal number and the number being operated on is not and if true increments the number being operated on to line up with the number being inputted.  It also sets the number being operated on to record as a decimal number.  We run the isBigger() to see which array is currently bigger and it is stored in a global variable.  Now, the program checks to see if any of the numbers are negative because if negative then they need to switch some of the arrays and either add or negate a negative sign.  The program checks to see if the number being operated on is negative and the number currently inputted is not.  If true, then the negatives are negated and the add function is run instead on the two numbers with the negative sign of B being set at the end then returns.  This is because subtracting a positive number from a negative number is the same thing as adding two negative numbers and tacking on a negative sign.  Then, the program checks to see if the number being operated on is negative and the number currently inputted is negative.  This is the same thing as adding a positive number to a negative number.  First it checks if it is big and if true swaps the two arrays and sets both to positive.  This is because A is bigger than B which means it needs to be in the operated on number and B needs to be in the number currently inputted to get the correct answer.  We also set the dummy variable here to 1 so that we can skip a check below since it would run true if not since we switched the arrays and negative flags.  If not bigger then we just set the currently inputted number to positive.  We finally just check whether the dummy variable has been called and if not true we check if the number being inputted is bigger and if true we swap and set the number being operated on to positive.  Now comes the actual manipulation of the arrays to figure out the resultant subtraction function since it passed all the checks and swapping and such.  First, we create a while loop that loops through the array elements one by one.  We calculated the value of the number being operated on minus the currently inputted number minus the carry.  The carry is just to see if we needed to use a carry in the previous decrement of the while loop, which is done in the next line to see if temp is less than zero, then we set the carry to high or 1 adding 10 to temp cause we basically adding 10 by carrying and otherwise we set the carry to 0.  We also reset the currently inputted number's each element to zero and then incremented the counter.  At the end outside the while loop, we set isDot to 0 so that the next currently inputted number would not have a decimal and set it to display the currently operated number or result number.</br></br>
<b>void multiply()</b></br>
The multiply function just multiplies the two arrays by manipulating them a bit.  First local variables are declared and then we go in the double nested while loop so that we could add up all the partial multiplications that were supposed to go in a certain box.  First we multiplied the i and jth term and added that to the j+i element of the temp array so store the current value for that digit of the resulting number.  We would do this until j+i+k is 7.  Then we needed to check to see if the inputTemp is greater than 9 which means it is carrying to the next inputTemp term.  We would add the tens digit of inputTemp to the element j+i+k+1 and the ones digit to the j+i+k element.  If not bigger than 9, then we would just break.  We then incremented the array appropriately by j++ and i++.  Then, we just looped through the inputTemp to put it into inputB.  Then we checked if the result should be set to negative.  If one of the negativeA or negativeB was negative or 1, then we set negativeB to negative as well.  Otherwise, we would set it to positive or 0.  Also, if the number being inputted was a decimal number, then we would decrement the result number to get the right number again.  Then we set displayInputA to 1 to display the resultant number.  Though this is a pretty complicated function for a relatively simple operation all we did was do long multiplication adding the resultant numbers each time instead of add them all at the end.</br></br>
<b>void divide()</b></br>
The divide function is pretty complicated as well.  First, we declared the local variables and then incremented the number being operated on by 2 so that it was like dividing by a number 100 times it basically tricking it to get two decimal places.  Then we created a while loop that runs as long as inputA is less than inputB.  Inside this loop we increment through the array subtracting inputA from B.  For how that works please refer to the subtraction function for that part.  We did this basically to count the amount of times that A goes into B by incrementing div.  We took div and put that into the elements of B in the next while loop.  So if div was 1234 then we would put 0 0 0 0 1 2 3 4 in the inputB array.  Next, we checked exactly the same way the negatives as in the multiplying.  Basically if there are two negative signs or two positive signs then we made it positive and we set it to negative when there is only one negative sign.  If there was a decimal in the currently inputted number then we decremented the array by 2.</br></br>
<b>int compar()</b></br>
The compare function is exactly like the isBigger function, which gets me why we did this twice but we're like that so we did.  It just loops down from the last elements and compares them to see if who has the bigger number highest which is the easiest way to compare two numbers.  First, we created a local variable i and set it to 7.  Then, we while looped through the 7th then 6th then....0th element to see which was bigger and returned 0 of A was smaller and returned 1 if A was bigger.</br></br>
<b>void ceil()</b></br>
Ceil basically just rounds a decimal number up.  If inputA is a decimal not .00 then it adds one to the ones digit and accounts for any carrying or 10 elements.  Then it decrements the array by two to get rid of the decimal and sets isDot to zero.  It does the exact same thing for B.</br></br>
<b>void tenToX()</b></br>
The tenToX function just incremented and decremented the array appropriately to perform the correct function.  First we declared local variables then figured out what the user wanted x to be and reset B if the number is bigger than 10.  Then we decremented or incremented appropriately depending on the negative sign.</br></br>
<b>void RTIISR()</b></br>
The RTI interrupt is way to big to do a paragraph that goes line for line so we'll just give you the jist and you can look at the rest of the comments to see exactly how it works.  Basically it resets the TFLG2 flag so that it will run again.  Basically there are different phases and in mine there are 8 phases because I was running two 4 digit LED displays.  We would shoot either 1110 1101 1011 or 0111 from port C which would go through the keypad and if there wasn't a correct PORTC input at 5V then we knew that that column was where the key was being pressed.  Since we knew the column and row from the 1110 etc combination that we sent out we know what key exactly would do the what we needed to do.  For the numbers we would just increment the array by that number.  If a complex function was pressed we would set the function variable to the appropriate switch int so that it would do the right function when the enter button is hit.  The enter button function is run when the enter key is pressed.  Also, since we connected the cathodes of the 4 digit LEDs to the RTI Phase this is where we would call the display() and displayB() functions so it would cycle correctly through which digit to display when since only one ground would go at once it was perfect for both the 4 digit LEDs.  Sometimes there were special functions like pi where we just set inputA to 3 1 4 or squared where we just set inputA to the inputB and chose the multiply function.  We also needed more buttons so we created a second key like on a calculator which when pressed activated a global variable which meant it would get the secondary key the next time that it was hit.</br></br>
<b>void incrementArray(int a)</b></br>
This function just increment array A by looping through the array elements through a while loop.  First, it sets a local variable which decrements from 7 to 0 by one and sets the previous element to the current element.  Then after the while loop it sets the first element of the array to zero.</br></br>
<b>void incrementArrayB(int a)</b></br>
This function just increment array B by looping through the array elements through a while loop.  First, it sets a local variable which decrements from 7 to 0 by one and sets the previous element to the current element.  Then after the while loop it sets the first element of the array to zero.</br></br>
<b>void swap()</b></br>
The swap function is pretty simple in that it just creates a local variable to loop through the elements of the array 8 times so that we can set the current elements of A to the current elements of B.</br></br>
<b>void isBigger()</b></br>
The isBigger function just checks to see which array is bigger by looping through the elements and seeing if A is ever bigger than B.  First, we declared a local variable to loop and set it to 7 and created an infinite loop that loops from the last element to the first.  We then compare the two values and if A is ever bigger than B then we se big to 1 and return because we know that A is bigger than B.  Otherwise, if B is bigger than A then we set big to 0 and return.  If none of these ever hit, big was set to 0 by default which basically means to do nothing.</br></br>
<b>void decrementArrayB(int a)</b></br>
This function just decrements array B by looping through the array elements through a while loop.  First, it sets a local variable which increments from zero to 6 by one and sets the next element to the current element.  Then after the while loop it sets the last element of the array to zero.</br></br>
<b>void decrementArrayA(int a)</b></br>
This function just decrements array A by looping through the array elements through a while loop.  First, it sets a local variable which increments from zero to 6 by one and sets the next element to the current element.  Then after the while loop it sets the last element of the array to zero.</br></br>
<b>main()</b></br>
Main function.</br></br>
</html>